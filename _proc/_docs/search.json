[
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "core",
    "section": "",
    "text": "Chronicle collects and stores logs and metrics in a series of parquet files.\nUse read_chronicle() to read either logs or metrics, by specifying the path to the parquet set you need.\nThe file tree looks like this, with logs and metrics in separate folders inside v1.\n.\n└── v1/\n    ├── logs/\n    └── metrics/\nInside both logs and metrics the data is stored by date, separated by year, month and day.\n.\n└── v1/\n    ├── logs/\n    │   └── 2023/\n    │       ├── 02/\n    │       │   ├── 01\n    │       │   ├── 02\n    │       │   ├── 03\n    │       │   ├── 04\n    │       │   ├── 05\n    │       │   └── ...\n    │       ├── 03\n    │       ├── 04\n    │       └── ...\n    └── metrics/\n        └── 2023/\n            ├── 02/\n            │   ├── 01\n            │   ├── 02\n            │   ├── 03\n            │   ├── 04\n            │   ├── 05\n            │   └── ...\n            ├── 03\n            ├── 04\n            └── ...\n\nsource\n\n\n\n read_chronicle (path:str)\n\nRead a chronicle parquet file into a polars dataframe.\n\n\n\n\nType\nDetails\n\n\n\n\npath\nstr\nPath to dataset\n\n\nReturns\nDataFrame\n\n\n\n\n\nz = read_chronicle(\"./data/v1/metrics\")\nassert type(z) == pl.dataframe.frame.DataFrame\n\nz = read_chronicle(\"./data/v1/logs\")\nassert type(z) == pl.dataframe.frame.DataFrame"
  },
  {
    "objectID": "core.html#analyse-metrics",
    "href": "core.html#analyse-metrics",
    "title": "core",
    "section": "Analyse metrics",
    "text": "Analyse metrics\n\nsource\n\nChronicleMetrics\n\n ChronicleMetrics (df:polars.dataframe.frame.DataFrame)\n\nInitialise a chronicle metrics class\n\n\n\n\nType\nDetails\n\n\n\n\ndf\nDataFrame\nA polars DataFrame\n\n\nReturns\nDataFrame\n\n\n\n\n\nsource\n\n\nChronicleMetrics.describe\n\n ChronicleMetrics.describe ()\n\nReads metrics dataframe and returns a pandas dataframe with summary of service, name and description of all metrics\nThe metrics data has a single row for each collected metric.\nUse describe() to get a DataFrame of the unique metrics in the metrics data, containing the service, name and description of each metric.\n\nm = read_chronicle(\"./data/v1/metrics/\").metrics.describe()\nassert list(m) == ['service', 'name', 'description', 'value_column']\nm\n\n\nsource\n\n\nChronicleMetrics.filter\n\n ChronicleMetrics.filter (name:str, alias:str=None)\n\nExtract a single metric from a metrics dataframe\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nname\nstr\n\nname of metric to extract\n\n\nalias\nstr\nNone\nalias to use for new column\n\n\nReturns\nDataFrame\n\n\n\n\n\nThe name argument is used to filter the DataFrame on the name column.\n\nm = read_chronicle(\"./data/v1/metrics/\").metrics.filter(\"rsconnect_system_memory_used\")\nassert type(m) == pd.DataFrame\nassert list(m) == ['host', 'timestamp', 'rsconnect_system_memory_used']\n\nm = read_chronicle(\"./data/v1/metrics/\").metrics.filter(\"rsconnect_system_memory_used\", \"memory\")\nassert type(m) == pd.DataFrame\nassert list(m) == ['host', 'timestamp', 'memory']\n\nm\n\n\nsource\n\n\nChronicleMetrics.plot\n\n ChronicleMetrics.plot (name:str, alias:str=None)\n\nPlot a selected metric using a Plotly line plot\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nname\nstr\n\nname of metric to extract\n\n\nalias\nstr\nNone\nalias to use for new column\n\n\nReturns\nline\n\n\n\n\n\n\nm = read_chronicle(\"./data/v1/metrics/\")\np = m.metrics.plot(\"rsconnect_system_memory_used\", \"memory\")\nassert str(type(p)) == \"<class 'plotly.graph_objs._figure.Figure'>\"\n\n\nread_chronicle(\"./data/v1/metrics/\").metrics.plot(\"rsconnect_system_memory_used\", \"memory\")"
  },
  {
    "objectID": "core.html#analyse-logs",
    "href": "core.html#analyse-logs",
    "title": "core",
    "section": "Analyse logs",
    "text": "Analyse logs\n\nsource\n\nChronicleLogs\n\n ChronicleLogs (df:polars.dataframe.frame.DataFrame)\n\nInitialise a chronicle logs DataFrame\n\n\n\n\nType\nDetails\n\n\n\n\ndf\nDataFrame\nA polars data frame\n\n\nReturns\nDataFrame\n\n\n\n\n\nFilter logs on type\nYou can\n\nsource\n\n\n\nChronicleLogs.filter_type\n\n ChronicleLogs.filter_type (value:str)\n\nExtract all logs where type == value\n\n\n\n\nType\nDetails\n\n\n\n\nvalue\nstr\nValue to extract\n\n\nReturns\nDataFrame\n\n\n\n\n\nlogs = read_chronicle(\"./data/v1/logs\").logs.filter_type(\"username\")\nassert type(logs) == pl.DataFrame\n\n# assert logs\n\n\nread_chronicle(\"./data/v1/logs\").logs.filter_type(\"username\")"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "chronicle",
    "section": "",
    "text": "Experimental - Work in progress\n\n\n\nThe purpose of this experimental package is to expose functionality to make it easy to read, filter and manipulate chronicle parquet files."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "chronicle",
    "section": "Install",
    "text": "Install\nThe package is not yet available on PyPi.\n#| include: False\npip install py_chronicle\nYou can install from github:\npip install git+https://github.com/andrie/py-chronicle"
  },
  {
    "objectID": "index.html#how-chronicle-stores-data",
    "href": "index.html#how-chronicle-stores-data",
    "title": "chronicle",
    "section": "How Chronicle stores data",
    "text": "How Chronicle stores data\nChronicle collects and stores logs and metrics in a series of parquet files.\nUse read_chronicle() to read either logs or metrics, by specifying the path to the parquet set you need.\nThe file tree looks like this, with logs and metrics in separate folders inside v1.\n.\n└── v1/\n    ├── logs/\n    └── metrics/\nInside both logs and metrics the data is stored by date, separated by year, month and day.\n.\n└── v1/\n    ├── logs/\n    │   └── 2023/\n    │       ├── 02/\n    │       │   ├── 01\n    │       │   ├── 02\n    │       │   ├── 03\n    │       │   ├── 04\n    │       │   ├── 05\n    │       │   └── ...\n    │       ├── 03\n    │       ├── 04\n    │       └── ...\n    └── metrics/\n        └── 2023/\n            ├── 02/\n            │   ├── 01\n            │   ├── 02\n            │   ├── 03\n            │   ├── 04\n            │   ├── 05\n            │   └── ...\n            ├── 03\n            ├── 04\n            └── ..."
  },
  {
    "objectID": "index.html#working-with-metrics",
    "href": "index.html#working-with-metrics",
    "title": "chronicle",
    "section": "Working with metrics",
    "text": "Working with metrics\nSome examples.\n\nread_chronicle(\"./data/v1/metrics\").head()\n\n\nread_chronicle(\"./data/v1/metrics/\").metrics.describe()\n\n\nread_chronicle(\"./data/v1/metrics/\").metrics.filter(\"rsconnect_system_memory_used\", \"memory\").head()\n\n\nread_chronicle(\"./data/v1/metrics/\").metrics.plot(\"rsconnect_system_memory_used\", \"memory\")"
  },
  {
    "objectID": "index.html#working-with-logs",
    "href": "index.html#working-with-logs",
    "title": "chronicle",
    "section": "Working with logs",
    "text": "Working with logs\nSome examples.\n\nread_chronicle(\"./data/v1/logs\").head()\n\n\nread_chronicle(\"./data/v1/logs\").logs.filter_type(\"username\").head()"
  }
]